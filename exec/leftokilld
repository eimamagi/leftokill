#!/usr/bin/python

from leftokill import config
from leftokill import core
from leftokill import log
import argparse
import daemon
import daemon.pidlockfile
import psutil
import os
import signal
import time
import threading

conffile = '/etc/leftokill/leftokill.conf'
pidfile = '/var/run/leftokill.pid'

def daemon_start(context_daemon, logger, loghandle, events, confopts):
    if context_daemon.pidfile.is_locked() and not \
            context_daemon.pidfile.i_am_locking():
        logger.error('Another instance is running (%s)' % \
                    context_daemon.pidfile.read_pid())
        raise SystemExit(1)

    if loghandle:
        context_daemon.files_preserve = [loghandle]

    def sigtermhandle(signum, frame):
        logger.info('Received SIGTERM')
        events['term'].set()

    context_daemon.signal_map = {
        signal.SIGTERM: sigtermhandle
    }

    logger.info('Starting instance')
    context_daemon.open()
    with context_daemon:
        core.run(confopts, logger, events)

def daemon_stop(context_daemon, logger):
    if context_daemon.pidfile.is_locked() and not \
            context_daemon.pidfile.i_am_locking():
        pid = context_daemon.pidfile.read_pid()
        process = psutil.Process(pid=pid)
        logger.info('Stopping instance (%s)' % pid)
        process.terminate()
        pgone, palive = psutil.wait_procs([process])

        for p in palive:
            p.kill()

def main():
    lobj = log.Logger()
    logger = lobj.get()
    loghandle = None
    events = dict()

    termev = threading.Event()
    events.update({'term': termev})

    confopts = config.parse_config(conffile, logger)

    for l in confopts['logmode']:
        if l.lower() == 'syslog':
            lobj.init_syslog()
        if l.lower() == 'file':
            lobj.init_filelog()
            loghandle = lobj.loghandle

    parser = argparse.ArgumentParser(prog='leftokilld')
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-n', dest='nofork', action='store_true',
                        help='do not fork into background')
    group.add_argument('-d', dest='daemon', type=str,
                       help='daemon arguments: start, stop, restart', metavar='')
    args = parser.parse_args()

    if args.nofork:
        try:
            core.run(confopts, logger, events)
        except KeyboardInterrupt:
            raise SystemExit(1)

    elif args.daemon:
        context_daemon = daemon.DaemonContext()
        context_daemon.pidfile = daemon.pidlockfile.PIDLockFile(pidfile)

        if args.daemon == 'start':
            daemon_start(context_daemon, logger, loghandle, events, confopts)

        elif args.daemon == 'stop':
            if not daemon_stop(context_daemon, logger):
                raise SystemExit(1)

        elif args.daemon == 'restart':
            logger.info('Restarting')
            daemon_stop(context_daemon, logger)
            daemon_start(context_daemon, logger, loghandle, events, confopts)


main()
